/*
Copyright (c) 2016 IBM Corporation and other Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.

Contributors:
Kim Letkeman - Initial Contribution
Howard McKinney- Initial Contribution
*/


// IoT Blockchain Demo Smart Contract
// v1   KL 20 Jan 2016 Initial contract supporting multiple assets with temp and gforce
// v1.1 KL 25 Jan 2016 Fixed a few issues, added setState to allow arbitrary JSON arg, added contract state management
// v2   KL 29 Jan 2016 CRUD pattern, remove deleted tracking, added JSON object models
// v2.1 KL 01 Feb 2016 Add location
// v2.2 KL 02-03 Feb 2016 timestamp detection and adjustment, add structures for event tracking, general cleanup
// v2.3 KL 02-04 Feb 2016 return nil from deploy and invoke, []byte from query
// v2.4 KL 06-10 Feb 2016 bulk arg, add read all assets, replace event history prototype with state history
// v2.5 KL 10 Feb 2016 RFC3339 timestamps, add extension field, use maps instead of structs, add deleteAllAssets
// v2.6 KL 14 Feb 2016 add Carrier, add readAssetHistory() to isolate the use of history from contract state
// v2.7 KL 16 Feb 2016 new API readAssetHistory map of asset to ordered array latest first parameterized count
//                     new API readRecentStates ordered array latest first of any state change max 20
//                     recent states will never show more than the number of assets, as they must be unique
// v2.8 KL 17-21 Feb 2016 AlertStatus in separate file, rules engine in separate file 
//                        separate the recent states to their own file
//                        align readAsset and readAllAssets output
// v2.9 KL 22 Feb 2016 inCompliance bool with addition to rules engine to handle it
//                     event string saving original arg for this state change
//                     delete readonly fields to avoid contamination of state, note that original event contains all sent fields
//                     renamed contract and folder to iot_blockchain_tradelane_beta_contract
// v3.0 HM 25 Feb 2016 Change where asset state history is stored -- store it in it's own bucket in the ledger.
//                     Moved the asset state history code into a separate package. 
// v3.0.1 HM 03 Mar 2016 Store the state history in descending order.  
// v3.0.2 KL 03 Mar 2016 Added a more complete sample object and a new API for the schema (generated by 
//                       the new generator for 3.1). No impact on tests except for version change. 
//                       also debuts the addition of readAssetEventSchema
// v3.0.3 KL 07 Mar 2016 production version with print statements suppressed 
// v4.0 KL 09-10 Mar 2016 renumbered to 4.0 because the schema changes are API breaking
//                     remove state caching for contract state, recent states, separated contract state into module
//                     ripped out bulk interface as it is guaranteed to create state inconsistencies
//                     deepMerge for maps of incoming event and ledger state
//         11 Mar 2016 reversed inCompliance to noncompliant so that the normal compliant contract does not have 
//                     any space taken up by the compliance section 
// v3.0.4 KL 14-15 Mar 2016 backport statelessness from 4.0, logging from 4.0, 
//                          remove bulk from 4.0, contractState module from 4.0
//                          cleaned up recenStates output, wrote new logging module
//           16 Mar 2016 fix alerts, merge example folder version with the hyperledger version (oops!), 
//                       add nickname, clean up logging      
// v3.0.5 KL 27 Mar 2016 add case insensitive JSON-RPC mode so that customers
//                       can choose how they want case handled on the wire     
// v4.0   KL 15 April 2016 Adapt contract to Hyperledger. Change shim imports. Add Init function.
//                         Rename Run to Invoke. Change schema to add new /chaincode service end point etc.
//                         Remove state structs (use schema and mapUtils.) Make fixes based on lint, e.g. fmt.Errorf.
//                         Update all docs to reflect the changes. 
// v4.1   KL May 27 2016 Store transaction UUID and timestamp in the state, aligning world state with the transaction 
//                       (and by definition the block) that is responsible for this specific asset state. Note: Initial
//                       commit of this version was at 4.0 and was in the trade lane folder. Subsequently moved to the iot 
//                       folder and updated to 4.1. Also:
//                         - Additional feature in 4.1 -- issue #4 -- rules engine must return err
//                         - Tweaks to deletePropertiesFromAsset (a bug found in the alert boilerplate using args instead of ledger)
//                         - Added postman tests for delete properties from asset and validation test rules
//                         - Reordered and normalized the rules engine call to make original event available and have consistency
//                           between create, update and delete properties.
// v4.2 KL May 28 2016 Replace all occurences of "incompliance" with "compliant" to remove an obvious source of confusion.
//                     Remove a copy paste error in the new testValidation rule where it was falling through and clearing
//                     the OVERTEMP rule, causing total havoc with that rule.

//********** start of history as Aviation Sample

// v4.3 KL June 2016 Added crud interfaces for four asset classes: airline, airplane,
// assembly, part; modified schema for new asset classes; modified contract state to 
// treat them separately; 


package main

import (
	"encoding/json"
	"errors"
	"fmt"
    "strings"
	"github.com/hyperledger/fabric/core/chaincode/shim"
)

//go:generate go run scripts/generate_go_schema.go


//***************************************************
//***************************************************
//* CONTRACT initialization and runtime engine
//***************************************************
//***************************************************

// ************************************
// definitions 
// ************************************

// SimpleChaincode is the receiver for all shim API
type SimpleChaincode struct {
}

// ASSETID is the JSON tag for the assetID
const ASSETID string = "assetID"
// TIMESTAMP is the JSON tag for timestamps, devices must use this tag to be compatible! 
const TIMESTAMP string = "timestamp"
// TXNTIMESTAMP is the JSON tag for transaction timestamps, which map directly onto the transaction in the blockchain
const TXNTIMESTAMP string = "txntimestamp"
// TXNUUID is the JSON tag for transaction UUIDs, which map directly onto the transaction in the blockchain
const TXNUUID string = "txnuuid"
// ArgsMap is a generic map[string]interface{} to be used as a receiver 
type ArgsMap map[string]interface{} 

var log = NewContractLogger(DEFAULTNICKNAME, DEFAULTLOGGINGLEVEL)

// ************************************
// start the message pumps 
// ************************************
func main() {
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		log.Infof("ERROR starting Simple Chaincode: %s", err)
	}
}

// Init is called in deploy mode when contract is initialized
func (t *SimpleChaincode) Init(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
    var stateArg ContractState
	var err error

	log.Info("Entering INIT")
    
    if len(args) != 1 {
        err = errors.New("init expects one argument, a JSON string with  mandatory version and optional nickname") 
		log.Critical(err)
		return nil, err 
	}

	err = json.Unmarshal([]byte(args[0]), &stateArg)
	if err != nil {
        err = fmt.Errorf("Version argument unmarshal failed: %s", err)
        log.Critical(err)
		return nil, err 
	}
    
    if stateArg.Nickname == "" {
        stateArg.Nickname = DEFAULTNICKNAME
    } 

	(*log).setModule(stateArg.Nickname)
    
    err = initializeContractState(stub, stateArg.Version, stateArg.Nickname)
    if err != nil {
        return nil, err
    }
    
    log.Info("Contract initialized")
	return nil, nil
}

// Invoke is called in invoke mode to delegate state changing function messages 
func (t *SimpleChaincode) Invoke(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	if function == "createAirline" {
		return t.createAirline(stub, args)
/*	} else if function == "createAirplane" {
		return t.createAirplane(stub, args)
	} else if function == "createAssembly" {
		return t.createAssembly(stub, args)
	} else if function == "createPart" {
		return t.createPart(stub, args)
*/
	} else if function == "updateAirline" {
		return t.updateAirline(stub, args)
/*	} else if function == "updateAirplane" {
		return t.updateAirplane(stub, args)
	} else if function == "updateAssembly" {
		return t.updateAssembly(stub, args)
	} else if function == "updatePart" {
		return t.updatePart(stub, args)
*/
	} else if function == "deleteAirline" {
		return t.deleteAirline(stub, args)
/*	} else if function == "deleteAirplane" {
		return t.deleteAirplane(stub, args)
	} else if function == "deleteAssembly" {
		return t.deleteAssembly(stub, args)
	} else if function == "deletePart" {
		return t.deletePart(stub, args)
*/
	} else if function == "deleteAllAirlines" {
		return t.deleteAllAirlines(stub, args)
/*	} else if function == "deleteAllAirplanes" {
		return t.deleteAllAirplanes(stub, args)
	} else if function == "deleteAllAssemblies" {
		return t.deleteAllAssemblies(stub, args)
	} else if function == "deleteAllParts" {
		return t.deleteAllParts(stub, args)
*/
	} else if function == "deletePropertiesFromAirline" {
		return t.deletePropertiesFromAirline(stub, args)
/*	} else if function == "deletePropertiesFromAirplane" {
		return t.deletePropertiesFromAirplane(stub, args)
	} else if function == "deletePropertiesFromAssembly" {
		return t.deletePropertiesFromAssembly(stub, args)
	} else if function == "deletePropertiesFromPart" {
		return t.deletePropertiesFromPart(stub, args)
*/

	} else if function == "setLoggingLevel" {
		return nil, t.setLoggingLevel(stub, args)
	} else if function == "setCreateOnUpdate" {
		return nil, t.setCreateOnUpdate(stub, args)
	}
	err := fmt.Errorf("Invoke received unknown invocation: %s", function)
    log.Warning(err)
	return nil, err
}

// Query is called in query mode to delegate non-state-changing queries
func (t *SimpleChaincode) Query(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	if function == "readAsset" {
		return t.readAsset(stub, args)
    } else if function == "readAllAssets" {
		return t.readAllAssets(stub, args)
	} else if function == "readRecentStates" {
		return readRecentStates(stub)
	} else if function == "readAssetHistory" {
		return t.readAssetHistory(stub, args)
	} else if function == "readAssetSamples" {
		return t.readAssetSamples(stub, args)
	} else if function == "readAssetSchemas" {
		return t.readAssetSchemas(stub, args)
	} else if function == "readContractObjectModel" {
		return t.readContractObjectModel(stub, args)
	} else if function == "readContractState" {
		return t.readContractState(stub, args)
	}
	err := fmt.Errorf("Query received unknown invocation: %s", function)
    log.Warning(err)
	return nil, err
}




// ************************************
// readAsset 
// ************************************
func (t *SimpleChaincode) readAsset(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
    var assetID string
	var argsMap ArgsMap
	var request interface{}
    var assetBytes []byte
    var found bool
	var err error
    
	if len(args) != 1 {
        err = errors.New("Expecting one JSON event object")
		log.Error(err)
		return nil, err
	}
    
    requestBytes := []byte(args[0])
    log.Debugf("readAsset arg: %s", args[0])
    
    err = json.Unmarshal(requestBytes, &request)
    if err != nil {
        log.Errorf("readAsset failed to unmarshal arg: %s", err)
		return nil, err
    }

    argsMap, found = request.(map[string]interface{})
    if !found {
        err := errors.New("readAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }
    
    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string) 
        if !found || assetID == "" {
            err := errors.New("readAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }
    
    found = assetIsActive(stub, assetID)
    if !found {
        err := fmt.Errorf("readAsset arg asset %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // Get the state from the ledger
    assetBytes, err = stub.GetState(assetID)
    if err != nil {
        log.Errorf("readAsset assetID %s failed GETSTATE", assetID)
        return nil, err
    } 

	return assetBytes, nil
}

// ************************************
// readAllAssets 
// ************************************
func (t *SimpleChaincode) readAllAssets(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
	var assetID string
	var err error
    var results []interface{}
    var state interface{}

	if len(args) > 0 {
        err = errors.New("readAllAssets expects no arguments")
		log.Error(err)
		return nil, err
	}
    
    aa, err := getActiveAssets(stub)
    if err != nil {
        err = fmt.Errorf("readAllAssets failed to get the active assets: %s", err)
		log.Error(err)
        return nil, err
    }
    results = make([]interface{}, 0, len(aa))
    for i := range aa {
        assetID = aa[i]
        // Get the state from the ledger
        assetBytes, err := stub.GetState(assetID)
        if err != nil {
            // best efforts, return what we can
            log.Errorf("readAllAssets assetID %s failed GETSTATE", assetID)
            continue
        } else {
            err = json.Unmarshal(assetBytes, &state)
            if err != nil {
                // best efforts, return what we can
                log.Errorf("readAllAssets assetID %s failed to unmarshal", assetID)
                continue
            }
            results = append(results, state)
        }
    }
    
    resultsStr, err := json.Marshal(results)
    if err != nil {
        err = fmt.Errorf("readallAssets failed to marshal results: %s", err)
        log.Error(err)
        return nil, err
    }

	return []byte(resultsStr), nil
}

// ************************************
// readAssetHistory 
// ************************************
func (t *SimpleChaincode) readAssetHistory(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
    var assetBytes []byte
    var assetID string
	var argsMap ArgsMap
	var request interface{}
    var found bool
	var err error

	if len(args) != 1 {
        err = errors.New("readAssetHistory expects a JSON encoded object with assetID and count")
		log.Error(err)
		return nil, err
	}
    
    requestBytes := []byte(args[0])
    log.Debugf("readAssetHistory arg: %s", args[0])
    
    err = json.Unmarshal(requestBytes, &request)
    if err != nil {
        err = fmt.Errorf("readAssetHistory failed to unmarshal arg: %s", err)
        log.Error(err)
        return nil, err
    }
    
    argsMap, found = request.(map[string]interface{})
    if !found {
        err := errors.New("readAssetHistory arg is not a map shape")
        log.Error(err)
        return nil, err
    }
    
    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string) 
        if !found || assetID == "" {
            err := errors.New("readAssetHistory arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }
    
    found = assetIsActive(stub, assetID)
    if !found {
        err := fmt.Errorf("readAssetHistory arg asset %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // Get the history from the ledger
    stateHistory, err := readStateHistory(stub, assetID)
    if err != nil {
        err = fmt.Errorf("readAssetHistory assetID %s failed readStateHistory: %s", assetID, err)
        log.Error(err)
        return nil, err
    }
    
    // is count present?
    var olen int
    countBytes, found := getObject(argsMap, "count")
    if found {
        olen = int(countBytes.(float64))
    }
    if olen <= 0 || olen > len(stateHistory.AssetHistory) { 
        olen = len(stateHistory.AssetHistory) 
    }
    var hStatesOut = make([]interface{}, 0, olen) 
    for i := 0; i < olen; i++ {
        var obj interface{}
        err = json.Unmarshal([]byte(stateHistory.AssetHistory[i]), &obj)
        if err != nil {
            log.Errorf("readAssetHistory JSON unmarshal of entry %d failed [%#v]", i, stateHistory.AssetHistory[i])
            return nil, err
        }
        hStatesOut = append(hStatesOut, obj)
    }
	assetBytes, err = json.Marshal(hStatesOut)
    if err != nil {
        log.Errorf("readAssetHistory failed to marshal results: %s", err)
        return nil, err
    }
    
	return []byte(assetBytes), nil
}


//***************************************************
//***************************************************
//* CONTRACT STATE 
//***************************************************
//***************************************************

func (t *SimpleChaincode) readContractState(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
	var err error

	if len(args) != 0 {
        err = errors.New("Too many arguments. Expecting none.")
		log.Error(err)
		return nil, err
	}

	// Get the state from the ledger
	chaincodeBytes, err := stub.GetState(CONTRACTSTATEKEY)
	if err != nil {
        err = fmt.Errorf("readContractState failed GETSTATE: %s", err)
        log.Error(err)
        return nil, err
	}

	return chaincodeBytes, nil
}

//***************************************************
//***************************************************
//* CONTRACT METADATA / SCHEMA INTERFACE
//***************************************************
//***************************************************

// ************************************
// readAssetSamples 
// ************************************
func (t *SimpleChaincode) readAssetSamples(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
	return []byte(samples), nil
}

// ************************************
// readAssetSchemas 
// ************************************
func (t *SimpleChaincode) readAssetSchemas(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
	return []byte(schemas), nil
}

// ************************************
// readContractObjectModel 
// ************************************
func (t *SimpleChaincode) readContractObjectModel(stub *shim.ChaincodeStub, args []string) ([]byte, error) {
	var state = ContractState{MYVERSION, DEFAULTNICKNAME, make(map[string]bool)}

	stateJSON, err := json.Marshal(state)
	if err != nil {
        err := fmt.Errorf("JSON Marshal failed for get contract object model empty state: %+v with error [%s]", state, err)
        log.Error(err)
		return nil, err
	}
	return stateJSON, nil
}

// ************************************
// setLoggingLevel 
// ************************************
func (t *SimpleChaincode) setLoggingLevel(stub *shim.ChaincodeStub, args []string) (error) {
    type LogLevelArg struct {
        Level string `json:"logLevel"`
    }
    var level LogLevelArg
    var err error
    if len(args) != 1 {
        err = errors.New("Incorrect number of arguments. Expecting a JSON encoded LogLevel.")
		log.Error(err)
		return err
    }
    err = json.Unmarshal([]byte(args[0]), &level)
	if err != nil {
        err = fmt.Errorf("setLoggingLevel failed to unmarshal arg: %s", err)
		log.Error(err)
		return err
    }
    for i, lev := range logLevelNames {
        if strings.ToUpper(level.Level) == lev {
            (*log).SetLoggingLevel(LogLevel(i))
            return nil
        } 
    }
    err = fmt.Errorf("Unknown Logging level: %s", level.Level)
    log.Error(err)
    return err
}

// CreateOnUpdate is a shared parameter structure for the use of 
// the createonupdate feature
type CreateOnUpdate struct {
    CreateOnUpdate bool `json:"createOnUpdate"`
}

// ************************************
// setCreateOnUpdate 
// ************************************
func (t *SimpleChaincode) setCreateOnUpdate(stub *shim.ChaincodeStub, args []string) (error) {
    var createOnUpdate CreateOnUpdate
    var err error
    if len(args) != 1 {
        err = errors.New("setCreateOnUpdate expects a single parameter")
		log.Error(err)
		return err
    }
    err = json.Unmarshal([]byte(args[0]), &createOnUpdate)
	if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to unmarshal arg: %s", err)
		log.Error(err)
		return err
    }
    err = PUTcreateOnUpdate(stub, createOnUpdate)
	if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to PUT setting: %s", err)
		log.Error(err)
		return err
    }
    return nil
}

// PUTcreateOnUpdate marshals the new setting and writes it to the ledger
func PUTcreateOnUpdate(stub *shim.ChaincodeStub, createOnUpdate CreateOnUpdate) (err error) {
    createOnUpdateBytes, err := json.Marshal(createOnUpdate)
	if err != nil {
        err = errors.New("PUTcreateOnUpdate failed to marshal")
		log.Error(err)
		return err
    }
    err = stub.PutState("CreateOnUpdate", createOnUpdateBytes)
	if err != nil {
        err = fmt.Errorf("PUTSTATE createOnUpdate failed: %s", err)
		log.Error(err)
		return err
    }
    return nil
}

// canCreateOnUpdate retrieves the setting from the ledger and returns it to the calling function
func canCreateOnUpdate(stub *shim.ChaincodeStub) (bool) {
    var createOnUpdate CreateOnUpdate
    createOnUpdateBytes, err := stub.GetState("CreateOnUpdate")
	if err != nil {
        err = fmt.Errorf("GETSTATE for canCreateOnUpdate failed: %s", err)
		log.Error(err)
		return true  // true is the default
    }
    err = json.Unmarshal(createOnUpdateBytes, &createOnUpdate)
	if err != nil {
        err = fmt.Errorf("canCreateOnUpdate failed to marshal: %s", err)
		log.Error(err)
		return true  // true is the default
    }
    return createOnUpdate.CreateOnUpdate
}
